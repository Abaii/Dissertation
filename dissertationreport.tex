\documentclass{article}% use option titlepage to get the title on a page of its own.
\usepackage{blindtext}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{subfigure}
\usepackage{cite}
\usepackage{minted}
\usepackage{mpshaskell}
\usepackage{forest}



\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{exmp}{Example}[section]

\title{Programming a tableau calculus for Predicate logic in Haskell.}
\date{01/05/2019\\}
\author{Abai Edmund\\  Supervisor: Georg Struth}


\begin{document}
\maketitle
\newpage
\section{Abstract} 
This report aims to formalise a tableau for propositional and predicate logic, using functional programming. It will detail all current knowledge of the field of Logic, focusing on propositional logic and touching on predicate logic. The tableaux method will also be outlined, including its use as a refutation method. Concepts in functional programming will be detailed, in particular, Haskell, including which concepts are used in the implementation of this project and why it is the most appropriate language of choice to employ for this specific project. This report aims to be an introduction to logic, functional programming and the method of analytical tableau. Lastly, testing is presented as well as future advancement that could improve the program given more time.
\newpage
\tableofcontents
\newpage
\section{Introduction}
\subsection{Setting the scene}
Dutch logician Evert William Beth created the method of analytical tableau in 1955 as a proof procedure. However, before discussing tableau, the field of Logic must be introduced.
Logic is a field of mathematics that plays a significant role in many aspects of Computer Science. As a mathematical field, it dates back to its inventor, Aristotle, and remained largely the same until the 20th century, where logic saw many advancements that lead to the development of formal systems such as predicate logic. \\
Logic boasts an array of practical uses; circuit design, computability theory and solvers such as model checkers. It is a vast subject area; however, this report will focus on studying and implementing the method of analytic tableaux; a proof procedure for logical formulas.\\
In logic, sentences are built which are evaluated to true or false values, such sentences to reason about the world - or more specifically a domain. For example, "It is raining outside" could be expressed using a logical formula; however, logic is unable to reason about more ambiguous or subjective sentences such as "That bed is too small.". This is unsurprising as logic is fundamentally a mathematical concept, and in the field of mathematics ideas such as ambiguity and subjectivity are not desirable. By combining sentences with connectives, more lengthy formulas can be built. These connectives can include but are not limited to: and; or; not; imply. Computer scientists are concerned with both truth and falsity values of such sentences as well as identifying methods to discern whether the formula in question is or can be true, perhaps even always true? Such an answer to that question is called a proof. Proof procedures are a way of deducing proofs from a logical formula. There are many widely used proof procedures that have been created, such as the Z3 theorem prover from Microsoft Research, CVC4 or Vaapire.

\subsubsection{Individual contributions}
The aim of this report is to provide a solid introductory explanation of Propositional and First-Order-Logic, the Haskell programming language and the method of analytical tableau. This main section of this report will detail the basic ideas behind both logical languages, fundamental concepts of functional programming and how tableau are created. Further it will detail a Haskell implementation to the following problems:
\begin{enumerate}
\item A representation of both predicate and propositional logic in Haskell.
\item An implementation for creating a Tableau for propositional logic, detailing the methods used to create the Tableau, the structure of the Tableau and the different functional programming concepts that were used to create the Tableau.
\item Implementing a unification algorithm for formulas.
\item Implementing a substitution algorithm for formulas.
\item An implementation for creating a Tableau for first-order logic. It will outline the same problems faced for propositional logic but adapted for first-order logic as well as an algorithm for unification, including what unification is and why it is needed for first-order logic tableau. 
\end{enumerate}
\subsection{Context for the contributions}
Both the unification and substitution algorithm are sub problems that need to be solved in order to create tableau for first-order logic. The implementations are outlined in the main area of the report which details the entire implementation process for creating a tableau for first-order logic. 


\subsection{Research question}
This report concerns itself with creating a tableau calculus in Haskell to check for validity and satisfiability in both propositional and First-Order-Logic statements. The report will explain  the process of creating a tableau calculus was broken into steps then implemented from the ground up. Ultimately, the aim is trying to deduce whether it is possible to create a proof for logical formulas

\section{Background}
\subsection{Propositional logic}
Propositional logic is a branch of logic that allows conclusions to be derived from statements called \textit{propositions}. Propositional logic requires a set of sentences called \textit{atomic sentences} that express some proposition and we combine them together using \textit{connectives} from a set of \textit{connectives}. Take the sentence \textit{"The sky is blue"}, which conveys the proposition that the sky is blue. We can combine this sentence with another such as \textit{"Water is wet"}, to form a compound sentence \textit{"The sky is blue, and water is wet"}, using the connective \textit{"and"}. This process can be repeated with more atomic sentences to create larger formulas. Propositional logic uses the connectives \textit{and, or, not and implies} these connectives operate the same as in boolean algebra.

For any given propositional formula we can assign True or False values to each atomic sentence, it is these binary values of the atomic sentence coupled with connectives which determine the value of the entire formula for which the atomic sentences create.\\ 
For example, taking the compound sentence, $s$, \textit{"The sky is blue and water is wet"}, there are two atomic sentences \textit{"The sky is blue"} and \textit{"water is wet"} which can be named $p$ and $q$ respectively. Let us assign values of \textit{true} to both $p$ and $q$ and sentence $s$  \\  
These true or false values assigned to such atomic sentences are called a \textit{model}. We are often concerned with whether there is a model for a given formula that would result in the formula being true, or whether every model yields a true result. Such a formula is called a \textit{tautology} which is explained in \textbf{3.1.2}.
\begin{figure}[h]
\hfill
\subfigure[Conjunction truth table]{\includegraphics[width=5cm]{and.png}}
\hfill
\subfigure[Disjunction truth table]{\includegraphics[width=5cm]{or.png}}
\hfill
\subfigure[Implication truth table]{\includegraphics[width=5cm]{implies.png}}
\hfill
\subfigure[Negation truth table]{\includegraphics[width=5cm]{not.png}}
\hfill
\caption{Truth tables for boolean operators }
\end{figure}
\subsubsection{Syntax of propositional logic}
As with all languages, propositional logic has a well-defined syntax and semantics. 
\begin{definition}
The alphabet of propositional logic.
\end{definition}
\begin{enumerate}
\item We use a set of propositional variables $P_1, P_2, ... $ to represent our atomic statements from a countably infinite set, $P$;
\item A list of symbols, $\land$, $\lor$, $\neg$  $\implies$, to denote connectives.
\end{enumerate}

Sentences in propositional logic are built by connecting the propositional variables with connectives. Each connective has n-arity which can be thought of as the number of arguments each connective takes. For example $\land$, $\implies$ and $\lor$ are binary connectives, $\neg$ is a unary connective. 
\begin{definition}
Formulas
\end{definition}
\begin{enumerate}
\item The set of propositional formulas can be defined by the following syntax.\\\\
\centerline{ F $\Coloneqq$ p $\vert$  $\neg$F $\vert$  F $\land$ F $\vert$  F $\lor$ F $\vert$ F $\implies$ F } \\\\
For all p $\in$ P.
\end{enumerate}
\subsubsection{Tatuologies}
A tautology is a logical statement which yields a true value for every given model. In other words it is always true. An example of such a sentence in plain English could be \textit{'"I am a man or I am not a man"} which could be expressed as $p \lor \neg{p}$ in propositional logic. Tautologies are \textit{valid}. 


\subsection{Predicate logic}

Predicate logic, also known as first-order logic, builds on the ideas of expressing logical sentences like propositional logic but allows for more complex sentences to be created. Predicate logic uses the same connectives, negation, conjunction, disjunction and implication however it extends propositional logic by allowing sentences to be built so that they quantify statements over a domain of discourse, or a given set of entities by using quantifiers. Quantifiers can express more complex sentences such as ”For all x in some domain” and ”There exists a given x in some domain” where our domain could be the natural numbers with each ”X” being a number or a room where each ”X” is a person.

\subsubsection{Syntax of predicate logic}
\begin{definition}
Alphabet 
\end{definition}
\begin{enumerate}
\item A set of countably infinite $V$ of variables. 
\item A set $F$ of function symbols, where each symbol has some fixed arity';
\item A set $P$ of predicate symbols, where each symbol has some fixed arity. 
\item The connectives, $\neg$, $\land$, $\lor$, $\implies$, $\forall$, $\exists$;
\end{enumerate}
We define constant symbols to be functions of arity 0. 
\begin{definition}
Terms. 
\end{definition}
\begin{enumerate}
\item The set of $T$ terms is a recursive definition: 
\end{enumerate}

\centerline{$T$ $\Coloneqq$ x $\vert$ f( $T_0$,..., $T_n$) }

Where x $\in$ $V$ and f $\in$ $F$ with an arity of n. 
\begin{definition}
Formulas. 
\end{definition}
\begin{enumerate}
\item Predicate symbols. Given a predicate symbol P  if P contains n terms then P is a formula with arity n. 
\item Negation. If P is a formula then $\neg$P is also a formula. 
\item Formulas with connectives. If P and Q are formulas then $P \land Q$ is a formula. The same rule applies for all logical connectives. 
\item Formulas within the scope of quantifiers. If P is a formula and x is a variable it follows that $\forall{x}P$ is a formula.
\end{enumerate}
Just like propositional statements, predicate formulas are evaluated to a true or false value. Predicates and connectives take true or false values in a similar way to variables in propositional logic. Terms can be thought of as expressions, they do not evaluate to some true or false value but perhaps to another value in some domain. For example, let us define a function $f(x)$ to mean the father of x whereas if we assign a predicate P(x,y) to mean $y$ is the father of $x$, it shows that functions define expressions \cite{struth_2019} whereas predicates define relations between symbols or state facts about said symbols. Predicates are also known as relational symbols. 
\subsection{Free and bound variables}
Quantifiers have a scope, in the same way a function block has a scope in a block of code. Variables that occur within the scope of a quantifier are said to be bound to that quantifier. 
\begin{definition}
Free and bound variables. 
\end{definition}
\begin{enumerate}
\item An occurrence of a variable x in a formula $\varphi$ is bound if x occurs in a subformula $\forall{x}\varphi$ or $\exists{x}\varphi$ of $\varphi$ \cite{struth_2019}
\item An occurrence of a variable x in a formula $\varphi$ is free if it is not bound. \cite{struth_2019}
\end{enumerate}
\begin{exmp}
Given the formula $\forall{x}(P(x) \implies P(y))$ we say the variable x is bound and y is free. 
\end{exmp}
\begin{exmp}
Computing the free variables of a formula. 
\end{exmp}
\begin{figure}[h!]
\centering
\includegraphics[scale=1]{freevar.png}
\caption{Algorithm to compute the free variables in a formula} \cite{struth_2019}
\label{fig:expansionrules}
\end{figure}
\subsection{The Haskell programming language}
\subsubsection{Introduction to Haskell}
All Haskell concepts mentioned below are based on Graham Hutton’s book \cite{hutton_2007}, Introduction to Haskell and \cite{learnyouahaskell}. Haskell is a pure, lazy, declarative, functional programming language developed in 1987 by an international committee of programming language researchers. A pure language is one which has no side effects where a side effect is an action which affects some internal state which value is then used to produce an output. Internal states like this do not occur in Haskell; this means that every call of some function with the same parameters will always yield the same results. The result of a function is fully dependent on the parameters passed to it and nothing else; we can also say that its value can replace any function call anywhere in the program and the meaning of the program will not change. \\\\
Given the function:\\
\begin{minted}{haskell}
double :: Int -> Int 
double x = x+2
\end{minted}
In a pure language we should be able to replace any expression double(2) with the Int, 4 and the meaning of the program should not change. 
Examples of impure actions include: 
\begin{enumerate}
\item Mutating the arguments of some function,$f$;
\item I/O operations;
\item Randomness, e.g implementing random number generators. 
\end{enumerate}
Haskell is a lazy language, which means Haskell only evaluates expressions when asked. For example, in an eager language (opposite of lazy) if asked to compute a list of all the square numbers up to 1000, it will compute every square number up to 1000 put each number in a list and then store that list. However, in a lazy language the square values will not be calculated until or unless a specific value or values are explicitly asked for. This allows for structures such as infinite lists to be created in Haskell and other lazy languages.\\\\
\subsection{Declarative verus Imperative}
Programming languages are tools used to solve problems. Declarative programming, a feature of Haskell, is a style of building solutions to problems by concerning itself on "What to do to solve the problem" not "How to solve the problem". To understand this explanation it is best to look at an example. Defining a function in python, an imperative language, that adds 5 to a list of numbers: 
\begin{minted}{python}
def addFive(numbers): 
for (i in range len(numbers): 
  numbers[i] = numbers[i] + 5
 return(numbers)
  	
\end{minted}
Our function $addFive$ explains "How", we can define our function at a high level as: "Take a list of numbers, iterate through the list, for each number, $i$, replace it with $i+5$, and continue until all numbers $i$ have been visited then return the list of numbers. "\\
However, defining a similar function in Haskell would require a different approach:
\begin{minted}{haskell}
addFive :: [Int] -> [Int]
addFive numbers = map (\x -> x + 5) numbers 
\end{minted}
The function $addFive$ in Haskell is explaining "what" to do, at a high level this function can be read as, "Apply the function (x+5) for all numbers, $x$," or more simply "Add 5 to each number in the list". \\\\
Functions in Haskell take one or more arguments and produce a single result. 
Consider the following Haskell function AddTwo: 
\begin{myFunctionStyle}
AddTwo x = x + 2
\end{myFunctionStyle}

To define a function in Haskell we must first define a type signature for that function which takes the function name, the type of it's parameters and the type of its output. Therefore the type signature of our function\begin{myFunctionStyle}
AddTwo x = x + 2
\end{myFunctionStyle} would be defined as \\ \begin{myFunctionStyle}
AddTwo :: Int -> Int 
\end{myFunctionStyle}\\
The double colon ,$::$, syntax can be read as "is of type of" and the $->$ syntax can be thought of as a binary connective which says takes some type and returns another type. Putting this together the function $AddTwo$ can be read as, "AddTwo is a function which takes an integer as a parameter and returns another integer." 
In this case AddTwo takes a variable \begin{myKeyWordStyle}{x}\end{myKeyWordStyle} and returns x + 2.
Haskell makes use of higher order functions, functions which are used within other functions, to build increasingly more complex functions. 
For example AddTwo(AddTwo x) will return x+4. 
%%% RECURSION
\subsubsection{Recursion}
A common pattern in Haskell is recursion. As Haskell is a pure programming language, and thus states inside functions cannot be modified, recursion is used as a powerful tool used widely to iterate through data structures and carry out operations on elements in these data structures. Recursive functions are functions which call themselves, they need a base case and a recursive call. Once called each value from the recursive call is added onto a stack until the base case is hit, the function then carries out the original operation 
Consider the following function 
\subsection{The Maybe type}
The maybe type is defined as:
\begin{minted}{haskell}
data Maybe a = Nothing | Just a  
   			deriving (Eq,Show,Read,Ord)
\end{minted}
This provides a way of dealing with error conditions, it is used in cases where functions have an error condition. These are used in the unification algorithm detailed in \textbf{section 4.4} and \textbf{section 6.5}. 
%% ALGEBRAIAC DATA TYPES
\subsubsection{Algebraic data types and Prop data type}
It is possible to create data types in Haskell, as well as algebraic data types \cite{learnyouahaskell}. Algebraic data types are types which can be created by combining other types together.
Data types in Haskell are formed by writing the keyword \begin{myKeyWordStyle}data\end{myKeyWordStyle} followed by the name of the data type and zero or more constructor(s). The name of the data type and constructors(s) must begin with a capital letter.
Examples of different data types in Haskell.
\begin{enumerate}
\item\textbf{Boolean data type:}
\begin{myTypeNameStyle}Data Bool = \begin{myConstructorStyle}True | False\end{myConstructorStyle} \end{myTypeNameStyle}
The data type \begin{myTypeVarStyle}Bool\end{myTypeVarStyle} represents the boolean values and can either have a True or False value. 
\item\textbf{Algebraic data type:}
Data \begin{myTypeNameStyle} MyDataType \end{myTypeNameStyle} = \begin{myConstructorStyle}  A Int | B String  \end{myConstructorStyle} 
The data type \begin {myTypeVarStyle}MyDataType \end{myTypeVarStyle} can take the value of one of the two constructors either \textit{A} or \textit{B} where A takes a value of type Int and B takes the value of type String.
\item\textbf{Algebraic data type:}
\begin{myTypeNameStyle}data AnotherDataType = \begin{myConstructorStyle}C Int Bool\end{myConstructorStyle}\end{myTypeNameStyle}
The data type here has a constructor \textit{C} where it is the composition of an Int and Bool type. 
\item\textbf{Recursive Algebraic data type:}
\begin{myTypeNameStyle}data Nat = \begin{myConstructorStyle}None | Succ Nat \end{myConstructorStyle}\end{myTypeNameStyle}
The Nat data type represents every natural number using recursion. The sequence of all the natural numbers can be derived by continually applying the Succ constructor on the previous value. 
For example. Succ (Succ (Succ None))) is equivalent to 1 + (1+(1+0) which equals 3.
\end{enumerate}
%%record syntax
\subsection{Haskell's record syntax}
Let us define a datatype called Car to represent some car as such: \\
\begin{myTypeNameStyle}Data Car = \begin{myConstructorStyle}Car String String  \end{myConstructorStyle} \end{myTypeNameStyle}
Where the first two String parameters represent the model and colour of the car respectively.
\\
We could then create a new car, myCar = Car  "Toyota" "Blue". Now in the case we want to retrieve the model of $myCar$ we could define a function,\\
\begin{myFunctionStyle}getCar :: Car -> String \end{myFunctionStyle}
\\
Defining a function as this for each parameter would be tedious, especially for a constructor which takes many parameters. This is where record syntax comes in handy. We can redefine our Car data type to look like this: \\\\
\begin{myTypeNameStyle}Data Car = \begin{myConstructorStyle}Car {model :: String, colour :: String }  \end{myConstructorStyle} \end{myTypeNameStyle}\\\\
Haskell creates functions named model and colour which take a Car datatype and return the model or the colour of that specific instance of Car.  
\subsection{Pattern matching and other useful techniques}
Functions in Haskell make great use of pattern matching to access data, there are a few useful pattern matching techniques that are often used in Haskell programs. Here are some examples and other useful techniques in Haskell which are used in the implementation sections of this report - $\textbf{Sections 5 and 6}$ 
\begin{itemize}
\item (x:xs) is a common pattern used, it represents a list and split the list into a head and tail, x being the head of the list and xs being the tail. This is often used to carry out operations on lists using recursion. 
\item Often when passing a value as a parameter we want to have access to both the value as a whole and the individual parts that may make it up. For example, given a list, $L$, we may pass it to some function $f$ as (x:xs) to access the head and tail but we may also want to be able to execute some action on $L$ as a whole. We use the @ notation in Haskell to do so, passing $L@(x:xs)$ into our function $f$ gives us access to our list in both formats. 
\item Function composition: Haskell functions are built by combing smaller functions, like in mathematics we can use function composition using a dot notation to chain different functions together. In Haskell $f (g x) = f . g $ this allows for more readable code. 
\item In Haskell a dollar sign, \$\ is syntactic sugar for brackets for readability. x \$\ y is equal to x(y).
\item When the value of a given parameter does not matter for our output we can replace it with an underscore which can be read as "whatever this input is". For example
\begin{minted}{haskell}
 baseCase :: [a] -> Int -> [a] 
 baseCase [] _ = [] 
\end{minted}
The second line can be read as "If an empty list is passed to our function baseCase regardless of what Int is passed in return an empty list.
\item Guards. The symbol $\vert$ is used to replace if statements guards are followed by predicates and if the predicate is evaluated to true the function outputs the value on the righthand side of the predicate. An example: 
\begin{minted}{haskell}
findFive :: [Int] -> Int 
findFive [] = -1
findFive (x:xs) 
  | x == 5 = x
  | otherwise = findFive xs 
\end{minted}
The function "findFive" is a recursive function which searches for a 5 in a list and outputs the number 5 if it is found and -1 otherwise. Whilst this function may not have much practical use we can see how the guards work. In our first condition our predicate $x==5$ is evaluated and if it is true $x$ is output, which will be 5. Our "otherwise" condition is more syntactic sugar which always evaluates to true, this can be thought of as if all previous cases fail then output some result. 
\end{itemize}
\section{Tableaux calculi}
As stated previously, the method of analytic tableau is a proof procedure. It proves the validity of formulas by method of proof by contradiction, that is given some formula $f$, $\neg{f}$ is input into the tableau and attempt to show $\neg{f}$ is invalid therefore proving that $f$ must be valid.\\ 
Tableau are tree data structures, to prove a formula $X$ is valid we begin by placing $\neg{X}$ at the root of the tree and apply expansion rules to $\neg{X}$, forming a tree with nodes labelled sub formulas of $X$ that are retrieved via expansion rules. 
\begin{definition}
Closedness.\\
For some branch $\theta$. $\theta$ is closed if some formula, $f$ and $\neg{f}$ appears on $\theta$. Consequently we say that a tableaux, T, is closed if for all branches, $\theta$ of T are closed. Any formula that produces a closed tableaux tree is said to be invalid. 
\end{definition}
Tableaux for propositional logic is comprised of five expansion rules, although this project is only concerned with three, building a tree by applying these rules to some formula $\neg{X}$, and checking for the for a closed tableaux. If $\neg{X}$ produces a closed tableaux we can say $X$ is valid. Predicate logic extends this by adding two extra rules for the quantifiers but the underlying ideas are the same. \\
To further understand tableau, we reference Melvin Fitting's book: First order logic and automated theorem proving. 

\subsection{Tableaux for propositional logic}
There are two expansion rules associated with the connectives for propositional logic $\beta$ and $\alpha$.

\begin{figure}[h!]
\centering
\includegraphics[scale=1]{inferencerules.png}
\caption{Tableau expansion rules for propositional connectives taken from Melvin Fittings: First order logic and automated theorem proving} \cite{fitting_2013}
\label{fig:expansionrules}
\end{figure}
\begin{itemize}
\item \textbf{$\beta$ rule} The beta rule states that if applied to a formula on some branch $\theta$ we extend the left and right subtree of $\theta$ by appending each argument of the formula to the subtrees.
\item \textbf{$\alpha$ rule} Applying the alpha rule to some formula on some branch $\theta$ we extend $\theta$, label the node with $\alpha_1$ then $\alpha_2$ afterwards. 
\item \textbf{$\neg$$\neg$ rule}. The double negation rule states, given a formula,  $\neg$$\neg$X on branch $\theta$ we extend $\theta$ and label the resulting leaf node of $\theta$ with X. 
\end{itemize}
We apply the beta rule and alpha rule to all formulas of the form $p \lor q$ and $p \land q$ respectively. For the creation of tableaux the expansion rules for $\top$ and $\bot$ will be ignored. 
Suppose we want to build a tableaux for the formula, $p\land q\lor \neg{p}$:
\begin{figure}[h!]
\centering
\begin{forest}
[ $\neg (p\land q\lor \neg{p})$  (1)
  [ $\neg (p\land q)\land \neg\neg{p}$ (2)
  	[
	 $\neg (p\land q)$ (3)
	  [
	  	$\neg\neg{p}$ (4)
		[ $p$ (5)
			[$\neg{p} \lor \neg{q} $(6)
				[$\neg{p}$ (7)]
				[$\neg{q}$ (8)]
			]
		]
	  ]
	]
  ]
]
\end{forest}
\caption{Tableaux tee for  $p\land q\lor \neg{p}$}
\label{tableaux}
\end{figure} \\\\
The proof begins by negating the original formula \textbf{1}. Then \textbf{2} is derived from the $\alpha$ rule from \textbf{1}, \textbf{3} and \text{4} are from \textbf{2} by the $\alpha$ rule. \textbf{5} is from \textbf{4} by the double negation rule, \textbf{6} is from \textbf{3} using the equality $\neg(p\land q) == \neg{p} \lor \neg{q}$. We then finally derive \textbf{7} and \textbf{8} via the $\beta$ rule from \textbf{6}. \\\\
\textbf{Figure 2} shows a contradiction on one branch, namely $p$ and $\neg{p}$ (5 and 7) however the second branch has no contradiction therefore the tableaux is still open, it is then deduced that our original formula is invalid. 
\subsection{Tableaux for predicate logic}
Extending our proof procedure for predicate logic starts with the introduction of two new rules, $\gamma$ and $\delta$, the rules for connectives are the same as propositional logic. We define these as follows: 
\begin{table}[h]
\centering
\begin{tabular}{lll}
\cline{1-2}
\multicolumn{1}{|l|}{$\gamma(x)$}                                     & \multicolumn{1}{l|}{$\delta(x)$}                                  &  \\ \cline{1-2}
\multicolumn{1}{|l|}{$\gamma(t)$ where t is an arbitrary ground term} & \multicolumn{1}{l|}{$\delta(c)$ where c is a new constant symbol} &  \\ \cline{1-2}
                                                                      &                                                                  & 
\end{tabular}
\caption{Gamma and delta rules taken from wikipedia \cite{wikipediatableau}}
\label{tab:FOLexpansionrules}
\end{table}\\
The gamma rule applies to the universal quantifiers namely, $\forall{x}\varphi$ and $\neg\exists{x}\varphi$ where $\varphi \in F$ and the $\delta$ rule applies to existential quantifiers, $\exists{x}\varphi$ and $\neg\forall{x}\varphi$. If our tableau contains a universal quantifier we are able to reuse the $\gamma$ rule anywhere in the tableau with the intent of choosing a ground term which will close the tableaux. 
\subsection{Tableaux for first-order logic and tableaux}
The issue with the $\gamma$ rule is we are able to choose any ground term, there are no specifications for ground term should be used in order to close the tableaux and it is true that the majority of ground terms will not help in closing the tableaux. We circumvent this problem by prolonging the choice of ground term until a contradiction can be made and apply a unification algorithm. \cite{fitting_2013} We now change our $\gamma$ rule to:
\begin{table}[h]
\centering
\begin{tabular}{l}
$\gamma(x)$                                                                      \\
$\gamma(x')$ where x' is a variable not occurring everywhere else in the tableau
\end{tabular}
\caption{Gamma rule with unification, taken from wikipedia \cite{wikipediatableau}}
\label{tab:gammawithunification}
\end{table}\\
Where the value of x' will be decided later when a contradiction can be made. 
However this now poses a new problem, our $\delta$ rule requires that the new constant $c$ that is introduced be fresh, however if we have not decided which parameters have been introduced yet we are unable to guarantee that $c$ will be fresh. Therefore the  
$\delta$ rule must be altered to ensure a fresh term is introduced:  
\begin{table}[h]
\centering
\begin{tabular}{|l|}
\hline
$\exists\delta(x)$                                                                                        \\ \hline
$\delta(f(x_1,...,x_n)$ \\ where f is a new function symbol and $x_1,...,x_n$ the free variables of $\delta$ \\ \hline
\end{tabular}
\caption{Updated delta rule, taken from wikipedia \cite{wikipediatableau}}
\label{tab:deltarule}
\end{table}\\

\subsection{Example of a tableau tree for predicate logic}

Suppose we have a branch $\theta$ which contains the formulas \{ P(x'), $\neg$P(f(c)) \}, it is clear to see branch $\theta$  can be closed by substituting the variable $x'$ with $f(c)$, our mechanism for doing such a substitution is called unification. 
\subsection{Unification}
Unification is a method used in various fields thus a large variety of unification algorithms, although the following is used:
\begin{definition}
Unification algorithm
\end{definition}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{unialgo.png}
\caption{Unification algorithm: Taken from Logic in Computer Science by Struth} \cite{struth_2019}
\label{fig:unification algorithm}
\end{figure}
the following is an implementation of an algorithm taken from Struth - Logic in Computer Science. \cite{struth_2019}
In \textbf{figure 3} the notation $E,s$ is an abbreviation of $E \cup s$ where E is a current set of substitutions.
At a high level the algorithm can be read as: 
\begin{enumerate}
\item If unifying two terms which are the same, delete it from the resulting set. 
\item If unifying two functions with the same arity, $n$, substitute the corresponding arguments for each of the function and add it to the set.
\item If unifying two functions which are not the same, e.g f() and g() then the algorithm fails.
\item If a substitution is of the form Function -> Variable then swap the terms and add it to the unifier.
\item If a substitution is of the form Variable "x" -> Term, and Variable "x" is not equal to the term and Variable "x" occurs in the term then the algorithm fails. \\
E.g $x$ cannot be unified with $f(x)$. 
\item If unifying two terms $x$ and $t$ then replace all terms $t$ is the set E with $x$ and add the substitution $x -> t$ to the set E. 
\end{enumerate}
This algorithm is computed on some set E recursively and terminates when no more rules are applied to the set E where the resulting set E represents the most general unifier of the original set of terms. 
\section{Implementing a Tableau calculus for Propositional logic}
Before tackling predicate logic, a tableau calculus for propositional logic was made as, it is a simpler task but still encompasses a lot of the work needed to create a tableau calculus for predicate logic. For both propositional and predicate logic, building a tableau calculus follows similar steps. \begin{enumerate}
\item Define the data types; 
\item Define the expansion rules; 
\item Implement these expansion rules and build a tree eagerly;
\item Check to see if the tableaux is closed, if so return true otherwise return false. 
\end{enumerate}
Predicate logic contained additional, more complex steps such as creating a unification algorithm and modifying expansion rules to introduce fresh parameters and Skolem functions. 
\subsection{Method of analytical tableau for Propositional logic}

\subsubsection{Defining a Formula data type}
The process of creating a tableau for propositional logic began with creating a data type to represent propositional formulas.  Modifying a version of the datatype used in Graham Hutton's book: Programming in Haskell in which he outlines a tautology checker. We can produce an algebraic data type which is used to create propositional statements in this project.
In Haskell, the data type \begin{myTypeVarStyle}Prop\end{myTypeVarStyle} is defined as such: 
\vspace{5mm}


data \begin{myTypeNameStyle} Prop \end{myTypeNameStyle} = \begin{myConstructorStyle} Var Char |\\\-\hspace{3.15cm}Not Formula |\\\-\hspace{3.15cm}Or Formula Formula |\\\-\hspace{3.15cm}And Formula Formula |\\\-\hspace{3.15cm}Imply Formula Formula \end{myConstructorStyle}\\
Propositional variables are represented by the \begin{myConstructorStyle}Var \end{myConstructorStyle}. \\
The \begin{myConstructorStyle}Not \end{myConstructorStyle} \begin{myConstructorStyle}And \end{myConstructorStyle} and \begin{myConstructorStyle}Imply \end{myConstructorStyle}, and \begin{myConstructorStyle}Imply \end{myConstructorStyle} constructors can take another \begin{myTypeNameStyle}Formula\end{myTypeNameStyle} data type as an argument, the recursive property allows us to chain propositional statements together to create more complicated statements. \begin{myConstructorStyle}Var \end{myConstructorStyle} can be thought of as the base case in such a recursive formula. 

In order to create a tableau, we must also define a data type to represent a tree data structure, the definition for a tree is as follows: \\\\
data \begin{myTypeNameStyle} Tree a\end{myTypeNameStyle} = \begin{myConstructorStyle} Empty | Node a (Tree a ) (Tree a) \end{myConstructorStyle}\\\\
This is another recursive data type, which can be read as a tree contains nothing (Empty) or it consists of a single node with a left and right subtree with each node labelled with some value of type $a$. 

A third data type was also defined called Lf, which stands for Labelled Formula, like so: 
\begin{minted}{haskell}
Data Lf = Lf {formula :: Formula, 
expanded :: Bool } 
\end{minted} 
The Lf data type is used to create formulas which have a boolean label attached to them, this boolean value is used later on when constructing a tableau as it indicates whether or not that formula in the tree has already been expanded. 
\subsubsection{Expansion rules}
The expansion rules were simple to implement and defined in a function named expandNode. Type signature for expandNode: \begin{myFunctionStyle} expandNode :: Tree Lf -> Tree Lf  \end{myFunctionStyle}.
The basic expansion rules where defined as follows: 
\begin{minted}{haskell}
expandNode :: Tree Lf ->  Tree Lf 
expandNode Empty  = Empty 
expandNode (Node (Lf (Var x) False) _ _) = Node (Lf (Var x) True) Empty Empty 

expandNode (Node (Lf (Not (Var x)) False) _ _) = Node (Lf (Not (Var x )) True)  Empty Empty 

expandNode (Node (Lf (Pred x t) False) _ _) = Node (Lf (Pred x t) True) Empty Empty
expandNode (Node (Lf (Not (Pred x t) )False) _ _)  = Node (Lf (Not (Pred x t)) True) Empty Empty


expandNode (Node (Lf (And x y) False) _ _)  = Node f' xy' Empty 
      where  f' = Lf (And x y) True
             xy' = Node (Lf x False) (Node (Lf y False) Empty Empty) Empty
 
expandNode (Node (Lf (Or x y) False) _ _)   = Node f' x' y'
  where f' = Lf (Or x y) True
        x' = Node (Lf x False) Empty Empty
        y' = Node (Lf y False) Empty Empty

expandNode (Node (Lf (Imply x y) False) _ _)  = Node f' x' y'
  where f' =  Lf (Imply x y) True 
        x' = Node (Lf (Not (x)) False) Empty Empty
        y' = Node (Lf y False) Empty Empty 

expandNode (Node (Lf (Not (Imply x y)) False) _ _)  = Node f' xy' Empty 
  where f' = (Lf (Not (Imply x y)) True)
        xy' = (Node (Lf x False) (Node (Lf (Not y) False) Empty Empty) Empty)    

-- Double negation law
expandNode (Node (Lf (Not (Not x)) False) _ _)  =  Node f' x' Empty
  where f' = (Lf (Not (Not x)) False)  
        x' = (Node (Lf x False) Empty Empty) 
-- De morgans laws
expandNode (Node (Lf (Not (Or x y)) False) _ _)  =  Node f' xy' Empty
  where f' = (Lf (Not (Or x y)) True)
        
        xy' = (Node (Lf (Not x) False) (Node (Lf (Not y) False) Empty Empty) Empty )

expandNode (Node (Lf (Not (And x y)) False) _ _)  =  Node f' x' y'
  where f' = (Lf (Not (And x y)) True) 
        x' = Node (Lf (Not x) False) Empty Empty
        y' = Node (Lf (Not y) False) Empty Empty
\end{minted}
The expand node function a node and expands it returning the node as the root and the resulting tree with the expansion of that node. All beta rules result in the tree creating a new branch and the alpha rules always add the formulas to the left subtree. Extra rules were added for De Morgans and double negation laws as well as applying simplifications to formulas where valid. For example $\neg{(p\land q)}$ = $\neg{p} \lor \neg{q}$.

\subsubsection{Placing nodes onto a tree}
The next task was creating a function which takes two formulas and applies them to the next left or right empty space on the current branch. 
\begin{minted}{haskell}

{-
  insertLR - takes a Lfs and places each argument on the next 
  left and right empty sub tree in an existing tree (Beta rule)
-}
insertLR :: Tree Lf -> Tree Lf -> Tree Lf -> Tree Lf 
insertLR leftF rightF tree@(Node x l r )
  | l == Empty = (Node x leftF rightF)
  | b == Empty && c == Empty = Node x (Node a leftF rightF) r
  | otherwise = insertLR leftF rightF l 
    where (Node a b c) = l
\end{minted}
This function is a recursive function which checks to find the next Empty space down the left subtree, once it finds it, it will place the two formulas on the left and right of that Empty space. 
We then carry on by defining a function which takes a tree and a node, applies the expansion rule to said node and appends it to the given tree using the insertLR function. We call this function: rules;
\begin{minted}{haskell}
{-
expands a formula and adds the formulas onto the end of the tree depending on whether its an alpha or beta rule.
-}
rules :: Tree Lf -> Tree Lf  -> Tree Lf 
rules Empty tree _ = tree 
rules node Empty _ = node
rules node tree   =   insertLR l r tree
    where (Node a l r) = expandNode node 
\end{minted}
Once we have those three functions in place and tested a function to generate the tableau could be created;
\begin{minted}{haskell}

createTableaux :: Tree Lf  -> Tree Lf
createTableaux Empty = Empty 
createTableaux (Node (Lf (Var x) False) l r) = Node (Lf (Var x) True) (createTableaux l) (createTableaux r)  
createTableaux (Node (Lf (Not (Var x)) False) l r) = Node (Lf (Not (Var x)) True) (createTableaux l) (createTableaux r)  

createTableaux f@(Node (Lf formula expanded) l r)
  | expanded =  Node (Lf formula expanded) (createTableaux l) (createTableaux r)
  | otherwise =  createTableaux \$\ rules f (Node (Lf formula True) (createTableaux l)  (createTableaux r)) 
\end{minted}
Generating the tableau works by taking the initial node, expanding it and adding the result of the expansion to the root node using the rules function and then labelling the root node as being expanded. That new tree is then passed back into the function; the expanded root node is ignored, and the function searches for nodes in the left and right subtree and expands them. The program repeats this process until it hits the base case Empty. The program eventually stops, as each formula is stripped with each expansion until the leaf node of any given branch contains a literal, each literal has no expansion, it adds an Empty to each leaf node and marks the literal as expanded. Therefore, eventually the tree searches every node, sees everything has been expanded, the nodes below the leaf nodes are Empty and then the resulting tree is returned. \\\\
\subsubsection{Closing and collecting branches} 
We can already see the benefit of using Haskell as a tableaux calculus has been generated in very few lines of code concisely. After creating the tableau, it follows to implement checking for closedness of each branch to determine validity needs. Firstly, the branches of a tree are collected and stored as a nested list where each nested list represents each branch of the tree. 
\begin{minted}{haskell}
--Gets branches of a tree
branch :: Tree Lf -> [[Formula]]
branch Empty = [[]]
branch (Node (Lf formula _) Empty Empty) =  [[formula]]
branch (Node (Lf formula _) l r) 
  | r == Empty =  map (formula:) (branch l)
  | otherwise =  map (formula :) (branch l++ branch r)
\end{minted}
branch is a recursive formula which works by adding each formula in a branch to a list and adding each branch to an outer list. 
The last step is to check for a formula $X$ and $\neg{X}$ in a single branch then apply that formula to each list in a nested list. If every list in that nested list is closed then we conclude the tableau is closed.
\begin{minted}{haskell}
--check for a closed tree 
treeIsClosed :: [Formula] -> Bool 
treeIsClosed [] = False 
treeIsClosed list@(x:xs)
  | var `elem` list && (Not var `elem` list) = True
  | otherwise = treeIsClosed xs
    where var = getVar x 

-- check for closed tableaux
tableauxIsClosed :: [[Formula]] -> Bool 
tableauxIsClosed [] = True 
tableauxIsClosed (x:xs) 
  | treeIsClosed x = tableauxIsClosed xs 
  | otherwise = False
\end{minted}
treeIsClosed is the auxiliary function which checks for a contradiction in a single list of formulas. getVar is an auxillary function used in treeIsClosed to extract the character of a variable and the negation of its variable to then check to see if the both the variable and its negation occur in the same branch. 

Finally, we combine each function into a single function which returns the true or false value dictating whether the tree is closed.
\begin{minted}{haskell}
isTautology :: Formula -> Bool 
isTautology = tableauxIsClosed . branch . createTableaux . createNode
\end{minted}
 isTautology makes use of Haskells function composition syntax. f.g x = f (g x). It combines the functions is a nice and readable way. This completes the implementation for tableaux for propositional logic. 
\subsection{Testing tableaux for propositional logic}
The implementation was tested against the validity checker shown in Hutton's book. A list of 50 different formulas is created, and the result feeding each formula into both validity checkers is put into a tuple and appended to a list. Another function is created which checks each tuple in the list, and calculates what percentage of the tuples contain the same binary value. 

\begin{minted}{haskell}
-- Feed formulas from a list to both validity checkers and append the results to a list of tuples
applyCheckers :: [Formula] -> [(Bool, Bool)]
applyCheckers [] = []
applyCheckers (x:xs) = (a,b):applyCheckers xs
  where a = isTautology x 
        b = isTaut x

-- compareResults: calculate how many of the results are the same
compareResults :: [(Bool, Bool)] -> Int -> Int
compareResults [] counter = counter
compareResults (x:xs) counter 
  | a == b = compareResults xs (counter + 1)
  | otherwise = compareResults xs counter
    where (a,b) = x
-- Calculate the percentage of equal results
calcPercentage :: [(Bool, Bool)] -> Float 
calcPercentage results = (correct / total) * 100
  where correct = fromIntegral $ compareResults results 0
        total = fromIntegral $ length(results)

showPercentage :: Float 
showPercentage = calcPercentage $ applyCheckers formulae
\end{minted}
Each function has the following functionality:
\begin{enumerate}
\item $ApplyCheckers$ - This function takes a list of formulae,  and computes the output for both isTautology and Hutton's validity checker. Each output is then placed into a tuple and appended to a list until no formulae remain to be tested. 
\item $CompareResults$ - Compare results takes a list, $l$ of tuples computed by $applyCheckers$ and a counter. Each tuple, $x$, in it's input to see if each element in $x$ are equal, if so the counter is incremented to represent another matching result. This process is repeated for each tuple $x_0,...,x_n$ where $n$ is the length of the list $l$. 
\item $CalcPercentage$ - A function used to calculate the percentage of tuples which contain the same value. It uses $CompareResults$ to calculate the amount of results are the same and calculates the amount of tuples in the list. Then it computes the amount of $\frac{Total correct results}{Total results} * 100$ to find the percentage of results which are correct. 
\item $showPercentage$ - The show percentage function is the final function which encompasses all the previous functions to give a single result displaying the percentage of formulae which give the same output for both $isTautology$ and Hutton's validity checker, $isTaut$.
\end{enumerate}
\subsection{Evaluation of results}
The testing shows that for all formulas, both checkers give the same output 100\%\ of the time. This increases faith that the implementation is working correctly, many different types of Formulae were tested, the properties tested included:
\begin{enumerate}
\item If some formula $A \land B$ returned some result, $R$, does $B \land A$ return the same result. This was tested for the connectives, $\land, \lor, \implies$.
\item Do formulae with multiple of the same connective return a correct result? For example: $A \land B \land C$, this was tested for each binary connective with varying lengths. 
\item Do formulae with multiple different connectives return a correct result? For example $A \implies B \lor C \and A$, this was tested with arbitrary combinations with formulas of different lengths. 
\item A varying number of both valid and invalid formulae were tested.  
\end{enumerate} 
However, there are improvements which could be made. Firstly, Hutton's validity checker needed to be modified slightly to compare it to $isTautology$. Specifically, Hutton defines a $prop$ data type to represent a propositional formula whereas $isTautology$ defines a $formula$ data type. $Prop$ does not contain a definition for implication and instead uses the equality $p \implies q == \neg{p} \lor q$, therefore the data types had to be changed to be compatible which required later functions in Hutton's code to also be modified. These changes could have been tested more rigorously to ensure the changes did not affect the correctness of the program; there could have been another testing procedure which tested Hutton's original code with the modified version to ensure the results were still the same, this would have decreased the likelihood that the testing was flawed. \\\\
An obvious improvement will be testing a larger range of formulae if the program is tested with 100s or 1000s of formulas while still giving correct results it would increase the faith in the program. Randomised formulas could also be an improvement. An attempt was made to create a random formula generator to be used as input for the formula as opposed to hard-coded formulas. A random formula generator never came to fruition as it randomisation is more complex in a pure language such as Haskell as randomisation is an impure function. To create random numbers, monads would have had to be used, however when entering the 'monadic world' it proved challenging to then use any result in a monad outside of said monad. Though if a random formula generator were complete, it would have been a large improvement to the tests as random formulas may cover cases that may have been missed of to test, and would increase the number of formulas to be tested.\\\\
Overall, the tests given return good results which suggest the implementation is without error; however, given more time further improvements could be implemented to strengthen this conclusion. 
\section{Implementing the Tableaux method for Predicate logic}
\subsection{Data types} 
To implement tableaux for Predicate logic, we begin by defining our data types to represent the alphabet of Predicate logic. We create a new data type named term to represent variables and functions.
\begin{minted}{haskell}
type Var = String 
data Term = Variable Var | Func (Var, Int) [Term] deriving (Eq)  
\end{minted}
Variables are quite straightforward, however function definitions are slightly more complex. Each function is created via the $Func$ constructor which takes a tuple (Var,Int) and a list of terms. The Var represents the name of the function and the Int represents the arity of the function, whereas the list of terms represents the list of arguments the functions take. Functions are defined recursively as functions can take other functions as arguments. 
Formulas in predicate logic are just an extension of propositional logic and can be represented in Haskell like so: 
\begin{minted}{haskell}
--Formula data type
data Formula = Var Char |
               Not Formula | 
               And Formula Formula | 
               Or Formula Formula | 
               Imply Formula Formula | 
               ForAll Var Formula |
               Exist Var Formula |
               Pred Var [Term]
               deriving Eq
\end{minted}
The definition for the quantifiers are very similar to the propositional formulas, however they contain a string which denotes the variable bound to the quantifier. The definition for a predicate is also straight forward, a string denoting the name of the predicate and a list of terms the predicate takes as arguments. 


\subsection{Introducing fresh parameters and new skolem functions}
To recap, when applying the gamma rule we create a formula $\gamma{x'}$ where x' is a new variable, and the beta rule introduces a fresh skolem function. 
To implement these rules, firstly a list of variables and skolem functions were created
\begin{minted}{haskell}
-- All variables and skolem functions
freshvars = ["v"++show(x)| x <- [1..]]

skolems = ["f"++show(x) | x <- [1..]]
\end{minted}
We then define a function which takes the name of a skolem function, calculates the arity and attaches the arity to that skolem function.
\begin{minted}{haskell}
-- Compute all Free Variables in a FOL formula
fV :: Formula -> [Term]
fV (Var x) = [Variable [x]]
fV (Pred x t) = occuranceA t
fV (Not x) = fV x
fV (Imply x y) = fV x ++ fV y
fV (And x y) =  fV x ++ fV y
fV (Or x y) =  fV x ++ fV y
fV (ForAll x f) = filter (\y -> y /= (Variable x)) (fV f)
fV (Exist x f) = filter (\y -> y /= (Variable x)) (fV f)
-- Create skolem function
skolemFunc :: Formula -> String -> Term
skolemFunc f s  = Func (s, length(freeVars)) freeVars
  where freeVars = fV f
\end{minted}
 The free variables of our existential formula are calculated using the auxiliary function fV which is an implementation of the algorithm outlined in \textbf{section 3.3}.
\subsection{Expansion rules and creating the tree}
The functions expandNode, rules and createTableaux stay largely the same as the definitions in propositional logic. However, these functions have been extended to receive a counter to keep track of the current variable and skolemn functions that have been introduced. In order to implement the expansion rules for first-order logic, there must be a mechanism to introduce fresh skolem functions for the beta rule and new parameters for the gamma rule. We must also define a function to replace all instances of "x" with said variable or skolem function. \\
To replace bound variables in a formula we define a function subst:
\begin{minted}{haskell}
{-
  Replace all occurances x in some quantified formula with x', where x' is a variable not occurring anywhere else in the tableau.
-}
subst :: Formula -> Term -> Formula 
subst (ForAll x p) x' = ForAll x p'
    where p' = subPred p (Variable x) x'
subst  (Exist x p) x' = Exist x p'
  where p' = subPred p (Variable x) x'
subst (And x y ) x' = And (subst x x') (subst y x')
subst (Or x y ) x' = Or (subst x x') (subst y x')
subst (Imply x y ) x' = Imply (subst x x') (subst y x')
subst (Not x ) x' =  Not (subst x x') 
\end{minted}
Formulas which contain quantifiers, quantify over predicates. Each predicate contains a list of variables, therefore in. order to substitute variables inside a quantified statement, the subst function must visit the arguments of each predicate and replace some specified term with another. Subst is a recursively defined, the definitions for the quantified statement containing one predicate is defined then a recursive call is made to substitute terms in formulas composed with more than one predicate. 

After functionality to substitute variables and introduce new formulas is implemented the expansion rules are defined. 
\begin{minted}{haskell}
-- FOL rules 
expandNode (Node (Lf f@(Exist x f') False) _ _) c =   Node f1 xy' Empty
  where f1 = (Lf (Exist x f') True)
        sf = skolemFunc f (skolems!!c)
        (Exist x f'') = subst f sf
        xy' = (Node (Lf (f'') False) Empty Empty) 

expandNode (Node (Lf f@(ForAll x f') False) _ _) c = Node f1 xy' Empty
  where f1 = (Lf (ForAll x f') True)
        ForAll x f'' = subst f (Variable (freshvars!!c))
        xy' = (Node (Lf(f'' ) False) Empty Empty)  

expandNode (Node (Lf (Not (ForAll x f)) False ) l r) c = expandNode (Node (Lf (Exist x (Not f)) False) Empty Empty) c
expandNode (Node (Lf (Not (Exist x f)) False ) l r) c = expandNode (Node (Lf (ForAll x (Not f)) False) Empty Empty) c
\end{minted}
The expansion rules for the connectives are the same as propositional logic, with the two expansion rules added, a new parameter c is introduced as a counter and the subst function is used to replace the bound variable with the $c^{th}$ index in the list of fresh variables for the $\gamma$ rule and the list of new Skolem function names for the $\delta$ rule.\\\\
  The $expandNode$ function for existential quantifiers takes the node $\exists\delta{x}f$ and adds a node to the left subtree containing $\delta{f''}$ where $f''$ is $f'$ with all occurrences of $x$ replaced with a new Skolem function, from $skolems!!c$ which takes the free variables of $\delta{x}$ as arguments. \\
ExpandNode does the same for universal as existential except it replaces all occurrences of $x$ in some formula $\forall{x}f$ with a new variable from the list of fresh variables, $freshvars$
There are two definitions for the equality laws $\neg\exists{x.f}$ == $\forall{x.}\neg{f}$ and $\neg\forall{x.f}$ == $\exists{x}\neg{f}$. \\
\subsection{Creating the tableaux}
Creating the tableaux for predicate logic is similar to propositional logic. However, a new function $predTabelaux$ is defined: 
\begin{minted}{haskell}
predTableaux ::  Tree Lf -> Int -> ([String], [String]) -> Tree Lf 
predTableaux Empty _ _ = Empty
predTableaux (Node (Lf (Pred x t) False) l r) c v = Node (Lf (Pred x t) True) (predTableaux l (c) v) (predTableaux r (c) v)
predTableaux (Node (Lf (Not (Pred x t)) False) l r) c v = Node (Lf (Not (Pred x t)) True) (predTableaux l c v) (predTableaux r c v)
predTableaux f@(Node (Lf formula True) l r)  c (fvars,skols) =   Node (Lf formula True) (predTableaux l (c+1) (fvars', skols')) (predTableaux r (c+2) (fvars', skols'))
  where (fvars', skols') = ((drop (c+1) fvars), (drop (c+1) skols))
        (fvars'', skols'') = ((drop (c+2) fvars), (drop (c+2) skols))
predTableaux f@(Node (Lf formula False) l r ) c (fvars,skols) = predTableaux newTree (c) (fvars,skols)
  where newTree = rules (f) (Node (Lf formula True) (predTableaux l (c+3) (fvars', skols'))  (predTableaux l (c+4) (fvars'', skols''))) c (fvars,skols)
        (fvars', skols') = ((drop (c+3) fvars), (drop (c+3) skols))
        (fvars'', skols'') = ((drop (c+4) fvars), (drop (c+4) skols))
\end{minted}
$PredTableaux$ begins with the definitions for an Empty tree, the base case, which returns Empty and defines the expansion rules for predicates as do nothing with the predicate but label it as expanded so that the program will stop with predicates, $literals$ as the leaves of the tree. \\\\
The idea behind the function works in a similar fashion to propositional logic, firstly the root node is visited, expanded and the result append to the existing tree and the root is labelled as expanded. The new tree is passed back into the function,  sees the root has been expanded and calls the function recursively on the left and right subtree of the root, this continues until the base case is reached and returns the tree. \\\\
However, the large difference between predicate and propositional logic is the introduction of fresh variables and new terms, therefore the function takes an integer and a tuple containing the two lists which represent the list of fresh variables and new skolem function names. \\\\
This integer and lists are passed from PredTableaux to the function $rules$ which then calls $expandeNode$ which expands the formula with a new variable or fresh skolem function depending on which rule is applied. The function $PredTableux$ is recursively called with a new integer and the previously used values dropped from the original list, therefore the same values will not be used again. 
\subsection{Applying Unification}
Firstly, a $Subst$ data type is defined to represent a list of substitutions:
\begin{minted}{haskell}
type Subst = [(Term,Term)]

\end{minted}
Implementing the unification algorithm from \textbf{section 4.4} required two functions:
\begin{minted}{haskell}
-- compute the most general unifier till no changes are made 
mgu :: Maybe Subst -> Maybe Subst -> Maybe Subst 
mgu Nothing _ = Nothing
mgu _ Nothing = Nothing
mgu set set' 
  | set == set' = set' 
  | otherwise = mgu set' (mgu' (resMaybe set') [])
{--
    mgu': Compute the most general unifier for a set of terms, takes the set of terms and the current unifier
--}

mgu' :: [(Term,Term)] ->  Subst ->  Maybe Subst 
mgu' [] sub =  Just sub 
mgu' (((Func (f,a) t),(Func (g,b) u)):xs) sub
  | f /= g =  Nothing
  | a == b && unifiable /= Nothing = mgu' xs ((zip t u)++sub)
  | otherwise = Nothing 
    where unifiable = mgu' (zip t u) [] 
mgu' ((t@(Func _ _), x@(Variable y )):xs) sub = mgu' xs ((x,t):sub)
mgu' o@((x,t):xs) sub 
  | x == t = mgu' xs sub
  | x /= t && x `elem` t' = Nothing
  | inSub && x `notElem` t' = mgu' xs ((x,t):(newSet)) 
  | otherwise = mgu' xs $ reverse ((x,t):sub)
    where t' = occurance t
          inSub = inSubst x sub
          newSet = replaceTerms sub [] x t
\end{minted}
$Mgu'$ is a helper function which implements the rules described in \textbf{Section 4.4} to each term in a list of substitution, $mgu$ then takes a set of substitutions, $E$, applies mgu' to the set to create a set, $E'$. $Mgu$ then compares $E$ to $E'$ if they are the same no changes have been made therefore return $E'$ otherwise recursively call the function and replace $E$ with $E'$. The Maybe Monad is handle sets of terms that are not unifiable. If a set is not unifiable then $Nothing$ is returned, \\
Next, a mechanism to apply a set of substitutions to a tree is implemented: 
\begin{minted}{haskell}
--Unify :: apply unfier to tree 
unify :: Subst -> Tree Lf -> Tree Lf 
unify [] tree = tree
unify (x:xs) tree = unify xs (fmap (applySub x) tree)
\end{minted}
The function $unify$ takes a set of substitutions and applies each substitution to each node in a given tree using the fmap functor. The auxiliary function $applySub$ is defined which applies a single substitution to a single node. \\\\
After creating the $unify$ and $mgu$ function it became apparent that $mgu$ function must take an original set of substitutions, which is a list however the program returns a tree data structure. Therefore the $branch$ function in the previous section is used to gather the branches. For each branch $\theta$ of the tree only one contradiction needs to be found to close the branch, additionally as the tree is expanded eagerly a contradiction can be found between literals instead of larger formulas. Therefore, a function $treeliterals$ is defined to gather the literals of a tree in predicate logic. 
\begin{minted}{haskell}
--collect literals in list of list of FOL formulas
treeliterals :: [[Formula]] -> [[Formula]] -> [[Formula]]
treeliterals (x:[]) list = (literals x []):list
treeliterals (x:xs) list =  treeliterals xs (litTree)
  where litTree = (literals x []):list
\end{minted}
$Treeliterals$ uses a helper function $literals$ to gather the literals of one branch. The function $literals$ takes a list of formulas and an empty list to represent the resulting list, each element in the list is added to the resulting list if it is a predicate or ignored otherwise resulting in a list of only predicates. This function is applied to every branch in the tree recursively in $treeliterals$.\\
For each literal in branch $\theta$ it is compared to every other literal in $\theta$ until two predicates contain the same number of arguments, then the arguments are paired up to create a list of tuples $[(Bool, Bool)]$, aka a $Subst$ and then the unification algorithm is run on that set. If they are unifiable, the substitution is added to a list. This process is repeated for every branch $\theta$ in the list resulting in nested lists of substitutions. These substitutions are then condensed into one list and applied to the original tree using $unify$. Call this new tree, $tree'$.
\begin{minted}{haskell}
-- resolve a tree
resTree :: [[Formula]] -> Subst -> Maybe Subst 
resTree [[]] sub = Just sub
resTree [] sub = Just sub 
resTree (x:xs) sub
  | resolve x == Nothing = Nothing 
  | otherwise = resTree xs ((resMaybe (resolve x)) ++ sub)
-- resolve: try to close a branch 
resolve :: [Formula] -> Maybe Subst
resolve [] = Nothing
resolve t@(x:xs) 
  | xs == [] = resolve $ filter (\x' -> x' /= x) t
  | substitution /= Nothing = substitution
  | substitution == Nothing = resolve $ filter (\x' -> x' /= (head xs)) t
    where terms = res' x (head xs)
          substitution = mgu (Just terms) (mgu' terms [])
\end{minted}
The function $resTree$ compares each literal to every other literal in a branch of formulas and attempts to find two literals which will unify, and it uses $resolve$ as an auxiliary function which applies to one branch this is called recursively on every branch of the tree.
Once $tree'$ is calculated the $branch$ function is once again used to gather the branches of the new tree and the check for a closed tableaux uses the same function $tableauxIsClosed$. The same as propositional logic.\\\\
Combining all of these results in a function $isTautPred$ which returns a true or false value depending on whether a formula is valid or not.

\begin{minted}{haskell}
createPredF :: Formula->Tree Lf
createPredF f = predTableaux (createNode f) 0 (freshvars,skolems)
getSub :: Tree Lf -> Subst
getSub t 
  | resTree (treeliterals (branch t) []) [] /= Nothing = resMaybe (resTree (treeliterals (branch t) []) [])
  | otherwise = []

isTautPred :: Formula -> Bool
isTautPred f = tableauxIsClosed branches
  where tree = createPredF f
        sub = getSub tree
        unifiedTree = unify sub tree
        branches = branch unifiedTree
\end{minted}
The function $createPredF$, takes a formula and creates a tableaux with the initial counter set to 0 and a tuple containing the list of free variables and new Skolem functions whereas the getSub function takes a tree and returns a substitution used to attempt to close the tree. Finally, $isTautPred$ computes a tree, $t$, from $createPredF$; computes a substitution, $s$, using $getSub$; then applies the $s$ to the tree $t$ to form a new tree $t'$; the branches of $t'$ are collected and passed to $tableauxIsClosed$ which displays whether the original formula is valid or invalid. 


\subsection{Testing}
In order to test tableaux for predicate logic, firstly the unification algorithm was tested. The tests were quite simple, examples of sets of terms having the unification algorithm carried out on them were found \cite{struth_2019} and the same formulas were input into the Haskell implementation and the results were compared. The algorithm was tested for different criteria which included:
\begin{enumerate}
\item Do substitutions of the form x->x get deleted?;
\item Can two of the same function with different arguments be unified;
\item Does the algorithm fail when unifying two functions with different names and different arity. 
\item Does the algorithm fail trying to unify terms such as x and f(x);
\item Are terms in the substitution replaced with x when unifying x->t. (The final rule in the algorithm) 
\end{enumerate}
After testing the implementation and comparing it to worked examples \cite{struth_2019} there were no mistakes, example substitutions which fit the criteria were also made up, as well as testing cases such as empty lists, and sets of terms with varying sizes. These tests could have been improved by increasing the amount of sets of formulas tested, 
\subsubsection{Evaluation}
Overall, whilst the testing did produce positive results it is evident that the tests were not rigorous enough. Due to time constraints, the amount of data used to test the functions was quite small. This increases the likelihood that there are cases which have not been tested which could result in the program failing. The program also has issues with introducing new variables and fresh skolem functions, certain formulas give unexpected results. For example, when testing the tautology $\forall{x.f} \lor \neg\forall{x.f}$. Ideally the program would produce a single branch containing the literals \{$P(x_1), \neg{P(f_1)}$\} which would then be unified with the substitution $x_1->f_1$ however the literals produced are \{$P(x_16), \neg{Pf_3}$\}. These unusual results do not cause an issue with the given example as the tableau can still be closed with the substitution $x_16 -> f_3$ the uncertainty of the behaviour of the program is cause for concern as it is likely there may be an example for which it does not work. Although, with the formulas tested no example was found for which the incorrect result was given.\\
However, the testing for predicate logic did help with identifying major bugs in the program. At first, the unification algorithm only computed the unifier for a set of terms once instead of applying the algorithm recursively until no more rules applied. This bug was discovered when the unifier returned by the program returned different results than the examples \cite{struth_2019} with the same input however the output the program returned was equal to the first step shown by the worked examples. 
Improvements that applied to testing for propositional logic also apply for predicate logic, for example a function which produced randomised formulas for propositional logic
The application of the unification algorithm could have been planned better, the ideal scenario for the application would be:
\begin{enumerate}
\item Create the tableaux as a tree data structure;
\item Compute a unifier using the tree;
\item Apply the unifier to the tree;
\item Check for closed branches. 
\end{enumerate}
Although, the application works more like this: 
\begin{enumerate}
\item Create the tableaux as a tree data structure;
\item Convert the branches of the tree to a list of lists;
\item Compute the unifier from the list of lists;
\item Apply the unifier to the original tree;
\item Convert the branches of the unified tree to a list of lists;
\item Check for closed branches.
\end{enumerate}
This sequence of steps is quite long winded, it includes a lot of converting from trees to nested lists to trees again to nested lists. This is due to the fact that in the beginning it was easier to create the tableau as a tree data structure but check for closed tableau using nested lists. However, the decision to use two data structures was created only with propositional logic in mind which does not require any unification algorithm. Therefore, a lack of foresight coupled with time constraints lead to a long winded solution to computing tableaux for predicate logic. This illustrates the fact that perhaps a more thorough plan should have been created with both propositional and predicate logic in mind. Even though the program gives promising results, there is most likely are some unnecessary steps in computing a tableau for predicate logic which may hinder performance for larger formulas. 
\section{Discussion}
\subsection{Summary}
This dissertation has provided:
\begin{itemize}
\item An introduction to propositional and first order logic.
\item An introduction to some basic concepts in Haskell and why it is the language of choice. 
\item An explanation of tableau calculus, what they are used for and how they work. 
\item How a tableau calculus was implemented for propositional logic.
\item How a tableau calculus was implemented for predicate logic. 
\end{itemize}
\subsection{Reflection}
\subsubsection{Difficulties with propositional logic.} 
Many difficulties were encountered when creating a tableau for both propositional and predicate logic. \\ 
Beginning with propositional logic, deciding how to represent the tableau posed many difficulties. At first, the decision between representing tableau as a tree data type as defined previously, or a list of lists, where the outer list represented the tree and the inner lists were the branches of the tree,  was to be considered. At first it appeared that creating the tableau would be more practical using trees, however checking for closedness of a tableau seemed much more practical to implement using a list of lists as traversing a tree data structure is much more challenging than searching for elements in a list. \\
Originally an attempt was made at using a list of lists but this ultimately failed as implementing the expansion rules proved to be a complicated task with nested lists, namely the beta rule. That is because, to implement the beta rule with such a data type, a new list would have to have been made every expansion to be added to the already existing nested lists which represented the current tableau, which proved to be problematic to implement in a language such as Haskell where one cannot mutate the inputs of a function. \\ 
Ultimately, a decision was made to attempt to implement the tableau using a tree data structure which came with complications itself. \\\\
The tree data structure is a recursively defined structure, therefore, the solution to creating a tableau was also recursive. Understand recursion with unfamiliar datatypes such as a tree as opposed to more commonly used datatypes such as lists was time consuming and is a fundamental technique needed to create a tableaux. A solution to generating a tableau was made for propositional logic, however, then the problem of checking for closed branches arose. Traversing up a tree did not seem to be possible with Haskell, however, in the end, the two methods were combined. A tree is used to create the tableau, then the branches are collected as a list of lists which then checks for closedness. 
\subsubsection{Difficulties with first order logic}
Creating a tableau for predicate logic proved to be more complicated than propositional logic. The ideas behind building the tree were the same. However, the most challenging areas of the implementation for predicate logic seemed to be. 
\begin{itemize}
\item Defining correct data types for predicate logic;
\item Creating a unification algorithm;
\item Applying the unification algorithm to a tree;
\item Introducing new parameters and fresh Skolem functions to a tableau 
\end{itemize}
\textbf{Defining correct data types} 
Unlike propositional logic, defining the data types for predicate logic did not seem as trivial. A separate data type had to be created for a term which proved to be slightly confusing, the difference between a Variable and a constant was an issue and it was not first clear how to differentiate between the two. It was not clear if a separate definition should have been made for a Constant and one for a Variable or what exactly counted as a term and how these terms would link with formulas. More reading and testing was needed than expected to create a data type for both a First-Order logic formula and term. \\\\
\textbf{Creating a unification algorithm} Creating an algorithm for unification was challenging as when dealing with predicates there were cases where variables inside predicates needed to be changed, this resulted in functions which needed to recurse not only over data types but also lists within those data types, which may also contain nested lists. Visualising recursion is a tough concept sometimes, and dealing with recursion over multiple types in one go was often difficult.
\textbf{Introducing new parameters and fresh Skolem functions}
The introduction of new parameters, when applying the gamma rule and the introduction of fresh Skolem functions when using the beta rule were challenging tasks. Keeping track of variables and functions was a very time-consuming task. In an imperative language, this would not be too difficult as a global counter could be created, or a variable could be updated within a function upon introduction of a new parameter or Skolem function. However, in Haskell, both of these ideas are not possible to implement in the same way as a global variable would mean the result of the function would be dependent on something other than the parameters which would result in an impure function.\\ 
Emulating global variables is possible using monads although due to time constraints, a lack of understanding of monads and implementing a feature like that was not possible. \\ 
Another method would be traversing the tree each time, keeping track of which variables have already been used and use a different one if need be although this posed more issues.\\
 Firstly it is impossible to search up a tree in Haskell, furthermore counting the number of variables and Skolem functions used would require some counter to be incremented which is once again not possible, moreover if it was possible it is not apparent how this information would be used to introduce a new function without passing in extra parameters. In the end, all functions which were used in the tableau creation function had to be changed to carry some counter which was updated each time to get the next variable or Skolem function needed, from two other functions which returned a list of fresh parameters and Skolem functions. 
\subsubsection{What has been learned}
During the course of this project, it became apparent that before commencing such a project a method planning task should be undertaken before writing any code. Many scenarios arose where several functions were made to create a larger function. However, something fundamental was forgotten in respect of the larger function which encompasses all the smaller functions together, requiring changes having to be made to previous functions or in some cases rewritten. It is also critical to have a solid understanding of the mathematical concepts underlying such a project before trying to implement any techniques. 
\section{Conclusion}
Conclusively, this project has produced a program which can build a tableau calculus for statements in both propositional and predicate logic; this included the implementation of, the expansion rules for tableaux calculus \cite{fitting_2013}, a unification algorithm, a substitution algorithm. The program takes a formula as an input, places the negation of the formula at the root of the tree, and a corresponding tableau is built using the defined rules, the tree is then checked for a contradiction and returns a value depending on whether the program believes the original formula is valid or not. \\\\Currently, the program works for all inputs that have been tested; however, testing could have been improved to increase the likelihood of the implementation being correct. Many difficulties were faced, more so with predicate logic than propositional however this is to be expected as creating a tableau for predicate logic was an extension of propositional logic. \\\\
The main issues were introducing fresh variables and new Skolem functions. 
Currently, the program is able to add new variables and new parameters when dealing with predicate logic; however the variables, while unique, are not always the expected variables. Ideally,  tests would be carried out, comparing results to a state of the art theorem prover such as Z3. However, this would require, another program which could translate between the data types defined in this report and the language the Z3 theorem solver uses, knowledge on how to work Z3 would also be needed. These additional tests could be applied to both propositional and predicate logic. \\
Overall, the project has been a success with a large amount of the original goals being achieved with the current tests showing promising results.
\subsection{Future work}
Given more time improvements could be made. An obvious example would be extending the implementation to other types of logic such as temporal logic. This extension would require a further understanding of logical concepts such as what temporal logic is and its use. To further improve testing, a random formula generator could also be created to allow a larger quantity of formulas to be tested. A random formula generator was an idea earlier on in the project; however, as stated previously, random numbers do not function the same in Haskell as imperative languages as randomness is not pure. More knowledge on monads would perhaps be needed or a deeper understanding of the Haskell language in general. Additionally, both propositional and predicate logic tableau could be combined in one function which identifies the user input as either a propositional or predicate logic statement and computes the appropriate tableau, checking for invalid inputs before starting. Another improvement could be creating a user interface to visually display the tableau to give a clear understanding of the steps although this could become impractical with longer formulas as the size of the tree produced would increase massively. 
\bibliography{bibliography}
\bibliographystyle{ieeetr}
\end{document}